<!DOCTYPE html>
  <html>
  <head>
    <meta charset=utf-8 />
    <title>Lerc in Leaflet</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

    <!-- Load Leaflet from CDN-->
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
    <script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>
    <!--script src="../node_modules/leaflet/dist/leaflet-src.js"></script-->

    <script src="./LercCodec.js"></script>

    <style>
      body {
        margin:0;
        padding:0;
      }

      #map {
        position: absolute;
        top:0;
        bottom:0;
        right:0;left:0;
      }

      #info-pane {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
        padding: 1em;
        background: white;
      }
    </style>
  </head>
  <body>

  <div id="map"></div>
  <div id="info-pane" class="leaflet-bar">
    <label>
    pixel range (m)
    </label>
    <input id="pixelRangeMin" type="text" value="0" onchange="lerc.redraw()">
    <input id="pixelRangeMax" type="text" value="8000" onchange="lerc.redraw()">

    <hr>

    <div id="pixel-value"></div>
  </div>

  <script>
    var url;

    var map = L.map('map', {
      noWrap: true
    }).setView([40, -100], 3);

    var lerc = L.tileLayer.canvas({
      noWrap: true,
      attribution: 'USGS, Esri <a href="https://github.com/Esri/lerc">LERC</a>'
    });

    lerc.drawTile = function(canvas, tilePoint, zoom) {
      var ctx = canvas.getContext('2d');
      var canvasPos = canvas.getBoundingClientRect();
      var url = 'http://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer/tile/' +
      zoom + '/' + tilePoint.y + '/' + tilePoint.x;

      var tile = lerc._tiles[tilePoint.x + ':' + tilePoint.y];
      var lerco = LERC();
      var xhr = new XMLHttpRequest();
      xhr.responseType = "arraybuffer";
      xhr.open("Get", url, true);
      xhr.send();
      var pixels, mask, min, max, height, width;
      xhr.onreadystatechange = function () {
        if (xhr.readyState == 4 && xhr.status == 200) {
          var decodedPixelBlock = lerco.decode(xhr.response, { returnMask: true });
	  // LERC elevation tiles have a one row and one column overlap
          width = decodedPixelBlock.width -1;
          height = decodedPixelBlock.height -1;
          // range suitable for the whole world
          min = document.getElementById('pixelRangeMin').value;
          max = document.getElementById('pixelRangeMax').value;
          pixels = decodedPixelBlock.pixelData;
          mask = decodedPixelBlock.maskData;

          var imageData = ctx.createImageData(width, height);
          var data = imageData.data;
          var f = 255 / (max - min);
          var pv = 0;
          for (var i = 0; i < width * height; i++) {
	    // Skip the last pixel in each input line
	    var j = i + Math.floor(i / width);
            pv = (pixels[j] - min) * f;
            data[i * 4] = pv;
            data[i * 4 + 1] = pv;
            data[i * 4 + 2] = pv + 128;
	    // Mask only gets returned when missing data exists
	    data[i * 4 + 3] = (mask && !mask[j]) ? 0 :255;
	  } 

          ctx.putImageData(imageData, 0, 0);
	  tile.decodedPixels = decodedPixelBlock
        }
      }
    }

    map.on('mousemove', function (e) {
      // the x/y of the tile url
      var layerPoint = map.project(e.latlng).floor();
      var tilePoint = layerPoint.divideBy(256).floor();

      // the actual <canvas> object
      var tile = lerc._tiles[tilePoint.x + ':' + tilePoint.y];

      // if we have a tile
      if(tile) {
        var block = tile.decodedPixels;
	var pointInTile = layerPoint.subtract(tilePoint.multiplyBy(256));

        // extract the pixel data from the canvas
        document.getElementById('pixel-value').innerHTML = "Elevation: " +
       	  block.pixelData[pointInTile.y * block.width + pointInTile.x] + "m";
	  } else {
        document.getElementById('pixel-value').innerHTML = "Elevation: undefined";
	  }
    })

    lerc.addTo(map);
  </script>
  </body>
  </html>
